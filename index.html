<!DOCTYPE html>

<h1>Fetch + Streams Demo</h1>

<style>
    * { box-sizing: border-box; }

    label, input, output { display: block; }
    input[type="text"] { width: 400px; }

    label { margin: 2em 0; background-color: #efe; }
    output { font-family: monospace; }

    #output { margin-top: 2em; }
</style>

<p>This demo will search the first billion digits of PI for a substring you specify, and tell you the position at
which it was found. It will do this without consuming a billion bytes of memory! And it won't even need to do text
decoding and string comparison, as it will operate on the bytes directly.

<form id="form">
    <label>
        Enter a substring to search for (bytes displayed below)
        <input type="text" id="substring" pattern="[0-9]+" required>
        <output id="bytes" for="substring"></output>
    </label>

    <input type="submit" value="Search!">

    <fieldset id="output" hidden>
        <progress id="progress"></progress>
        <output id="progress-text"></output>
    </fieldset>
</form>

<script>
(function () {
    'use strict';

    // Polyfill until Canary updates
    ReadableStreamReader.prototype.read2 = function () {
        return this.ready.then(function () {
            if (this.state === 'readable') {
                return { value: this.read(), done: false };
            } else {
                return this.closed.then(function () {
                    return { value: undefined, done: true };
                });
            }
        }.bind(this));
    };

    const PI_URL = 'http://stuff.mit.edu/afs/sipb/contrib/pi/pi-billion.txt';

    const substring = document.querySelector('#substring');
    const bytes = document.querySelector('#bytes');
    const form = document.querySelector('#form');

    const output = document.querySelector('#output');
    const progress = document.querySelector('#progress');
    const progressText = document.querySelector('#progress-text');

    const encoder = new TextEncoder();

    let bytesValue = new Uint8Array();
    substring.addEventListener('input', function () {
        bytesValue = encoder.encode(substring.value);

        const bytesAsStrings = Array.prototype.map.call(bytesValue, function (b) { return `0x${b.toString(16)}`; });
        bytes.value = Array.prototype.join.call(bytesAsStrings, ' ');
    });

    let soFar;
    let contentLength;

    form.addEventListener('submit', function (e) {
        e.preventDefault();
        output.removeAttribute('hidden');

        progressText.textContent = 'Performing fetch...';

        fetch(`https://cors-anywhere.herokuapp.com/${PI_URL}`).then(function (res) {
            soFar = 0;
            contentLength = res.headers.get('Content-Length');
            progress.max = contentLength;

            return pump(res.body.getReader());
        })
        .catch(function (e) {
            progressText.textContent = e;
        });
    });

    function pump(reader) {
        return reader.read2().then(function (result) {
            if (result.done) {
                progressText.textContent = `All done! (${soFar} bytes total)`;
                return;
            }

            const chunk = new Uint8Array(result.value); // should be Uint8Array already though, not ArrayBuffer

            soFar += chunk.byteLength;
            updateProgress();

            let found = -1;
            for (let i = 0; i < chunk.length; ++i) {
                if (chunk[i] === bytesValue[0]) {
                    found = i;
                    for (let j = 1; j < bytesValue.length; ++j) {
                        if (chunk[i + j] !== bytesValue[j]) {
                            found = -1;
                            break;
                        }
                    }
                }

                if (found !== -1) {
                    break;
                }
            }

            if (found !== -1) {
                progressText.textContent = `Found it! At position ${soFar - chunk.byteLength + found}.`;
                return reader.cancel('Found it, no more data needed!'); // BUG: argument should be optional
                // BUG: cancel doesn't actually do anything.
            } else {
                return pump(reader);
            }
        });
    }

    function updateProgress() {
        progressText.textContent = contentLength ?
            `${soFar}/${contentLength} bytes received` : `${soFar} bytes received`;
        progress.value = contentLength ? soFar : null;
    }
}());
</script>
